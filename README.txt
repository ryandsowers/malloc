malloc3140 README

Memory allocations are tracked with a 16 byte header. The first 8 bytes indicate the size of any blocks previous to the current or requested block (or zero if at the beginning of the heap). The second 8 bytes indicate the size of the following memory block, and includes a use-bit at the lowest position. This use-bit is flipped to 1 if the following block is in use, and it is flipped to 0 if the block is free.

If we end up going through the whole heap to find a free block to allocate and have not found a block that will satisfy our requirement, then we will extend the heap in "l_malloc.extend_heap." This will then update the header of the last free block in our heap (which could be the top of the new heap) with the available free space that follows. Now the process of checking availability and size of this block will repeat and will take us to "l_malloc.found_best_fit." The heap is grown by calling "set_brk" (brk syscall) with the new "heap_end" address that we want (adding 0x20000 bytes).

Freeing memory involves flipping the use bit of the designated block to 0, and then coalescing any free previous or following blocks. Coalescing is done by first checking if the following block is free by examining the use-bit in its header. If it's free, we can add its size to our "cur_size" variable that is tracking how large the new block will be. In either case, we'll next go to the previous block and examine its use-bit in the same way. If it's free, its size is added to the total and that value is placed in that header. If it's not free, we go to update the header of the block we started at.

The memory manager program was tested by calling "l_malloc" of various sizes and "l_free" in various orders and examining the headers throughout the process to ensure the desired results were obtained. "l_malloc" was called for block sizes larger than the available heap to test for heap extension. It was called for a block size that was exactly as large as the available heap to see if the heap would be extended or wait until the next call, and to also see if there were any issues with header creation. "l_free" was called first for blocks at the end, then for blocks in the middle, and finally for blocks at the beginning to ensure that the order did not affect the ability to coalesce free blocks and update the appropriate headers.

The .c test file contains a call to "get_brk" so we know the address of the start of the heap. Then there are several calls to "l_malloc", after which we print the allocated memory address. By adding the allocated memory block to the allocated address, one can determine whether or not the correct block size was allocated. For example, I allocate a 16 byte block at 0x73eff0. The next block is then allocated and returns a start value of 0x73f010. We know that there are 16 bytes allocated between the two plus a 16 byte header. We add 32 bytes to the first address (0x73eff0 + 0x20 = 0x73f010) and we can see that we've obtained the correct addresses.